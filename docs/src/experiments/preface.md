# 实验 / 前言

我们这门课，一共安排了 4 个子实验，分别对应编译的四个阶段（具体情况待定，但是差不多就这样了）。按开始时间顺序，它们分别是：

- 词法分析（1--2 周）
- 文法分析（2--3 周）
- 类型检查（2 周）
- 代码生成（3 周）

早做完的话……应该没有加分吧。

## 关于示例代码

从下一篇文章开始就是实验的正文了。鉴于大家都学过 Java，实验中涉及到的示例代码我就都以类似 Java 的格式来写了（因为是示例代码，不保证能够运行；况且你们也不用运行这个东西）。

如果你用的是 C++、C#、Kotlin 或者其他 OOP 风格的语言，绝大部分情况你应该可以找到自己语言里与 Java 相对应的语法成分，并且将 Java 代码的思想翻译过去（毕竟 Java 是那种最正统的 OOP，其他语言的功能只会更强）。

如果你用的是 Haskell、F#、Scala、Rust 等具有一部分或全部函数式风格的语言，我相信你具有的知识足以将 OOP 风格的代码转换成函数式的。顺便一提，在遇到继承的时候，你可以放心大胆地把继承统统改成和类型，因为几乎所有*会用到*继承的地方都是私有的类。

如果你使用语言的是 C ……那只好祝你好运了。或许换个现代一点的语言写起来会更舒服。

## 关于脚手架

鉴于上学期绝大部分同学使用的语言是 Java、C++ 和 Python，我们为这三门语言提供了脚手架代码，希望可以减轻同学们实现与编译过程无关的代码的负担。不使用脚手架代码对实验**没有任何影响**。如果你使用的是 Rust，你也可以在不使用 `syntax::parser` 和 `syntax::lexer` 的情况下使用 `syntax` 和 `r0vm` 两个 crate。

脚手架代码会    包括如下内容：

- 对编译过程中涉及的元素的抽象及输出辅助函数
  - Token（单词）和 TokenKind（单词类型）
  - 与 AST（抽象语法树）相关的语法结构（如表达式）
  - 虚拟机汇编文件（S0）
- 编译步骤类的接口
  - Lexer, Parser 和 Codegen
- 主函数？

脚手架代码将在实验正式开始之前提供给大家。

## 关于代码提交

如果你至今为止都在使用 IDE，可能是时候了解一下编译你的代码所用的命令行指令了。本次实验中，所有的作业代码都会在 Linux 环境里进行运行和评分。具体评分规则和提交标准见 [评测姬说明文档][judge]。

[judge]: ../judge.md
